declare module Ammo {
  declare class btHingeConstraint {
    constructor();
    constructor(rbA: btRigidBody, rbB: btRigidBody, pivotInA: btVector3, pivotInB: btVector3, axisInA: btVector3, axisInB: btVector3, useReferenceFrameA: boolean);
    constructor(rbA: btRigidBody, pivotInA: btVector3, axisInA: btVector3, useReferenceFrameA: boolean);
    constructor(rbA: btRigidBody, rbB: btRigidBody, rbAFrame: btTransform, rbBFrame: btTransform, useReferenceFrameA: boolean);
    constructor(rbA: btRigidBody, rbAFrame: btTransform, useReferenceFrameA: boolean);
    buildJacobian(): void;
    getInfo1(info: btConstraintInfo1): void;
    getInfo1NonVirtual(info: btConstraintInfo1): void;
    getInfo2(info: btConstraintInfo2): void;
    getInfo2NonVirtual(info: btConstraintInfo2, transA: btTransform, transB: btTransform, angVelA: btVector3, angVelB: btVector3): void;
    getInfo2Internal(info: btConstraintInfo2, transA: btTransform, transB: btTransform, angVelA: btVector3, angVelB: btVector3): void;
    getInfo2InternalUsingFrameOffset(info: btConstraintInfo2, transA: btTransform, transB: btTransform, angVelA: btVector3, angVelB: btVector3): void;
    updateRHS(timeStep: number): void;
    getRigidBodyA(): btRigidBody;
    getRigidBodyB(): btRigidBody;
    getRigidBodyA(): btRigidBody;
    getRigidBodyB(): btRigidBody;
    getFrameOffsetA(): btTransform;
    getFrameOffsetB(): btTransform;
    setFrames(frameA: btTransform, frameB: btTransform): void;
    setAngularOnly(angularOnly: boolean): void;
    enableAngularMotor(enableMotor: boolean, targetVelocity: number, maxMotorImpulse: number): void;
    enableMotor(enableMotor: boolean): void;
    setMaxMotorImpulse(maxMotorImpulse: number): void;
    setMotorTargetVelocity(motorTargetVelocity: number): void;
    setMotorTarget(qAinB: btQuaternion, dt: number): void;
    setMotorTarget(targetAngle: number, dt: number): void;
    setLimit(low: number, high: number, _softness: number, _biasFactor: number, _relaxationFactor: number): void;
    getLimitSoftness(): number;
    getLimitBiasFactor(): number;
    getLimitRelaxationFactor(): number;
    setAxis(axisInA: btVector3): void;
    hasLimit(): boolean;
    getLowerLimit(): number;
    getUpperLimit(): number;
    getHingeAngle(): number;
    getHingeAngle(transA: btTransform, transB: btTransform): number;
    testLimit(transA: btTransform, transB: btTransform): void;
    getAFrame(): btTransform;
    getBFrame(): btTransform;
    getAFrame(): btTransform;
    getBFrame(): btTransform;
    getSolveLimit(): number;
    getLimitSign(): number;
    getAngularOnly(): boolean;
    getEnableAngularMotor(): boolean;
    getMotorTargetVelocity(): number;
    getMaxMotorImpulse(): number;
    getUseFrameOffset(): boolean;
    setUseFrameOffset(frameOffsetOnOff: boolean): void;
    getUseReferenceFrameA(): boolean;
    setUseReferenceFrameA(useReferenceFrameA: boolean): void;
    setParam(num: number, value: number, axis: number): void;
    getParam(num: number, axis: number): number;
    getFlags(): number;
    calculateSerializeBufferSize(): number;
    serialize(dataBuffer: void, serializer: btSerializer): string;
  }
}
