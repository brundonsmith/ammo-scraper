declare module Ammo {
  declare class btRigidBody {
    constructor(constructionInfo: btRigidBodyConstructionInfo);
    constructor(mass: number, motionState: btMotionState, collisionShape: btCollisionShape, localInertia: btVector3);

    get_btRigidBody(): static;	set_btRigidBody(value: static): static;
    get_const(): static;	set_const(value: static): static;
    get_m_contactSolverType(): number;	set_m_contactSolverType(value: number): number;
    get_m_frictionSolverType(): number;	set_m_frictionSolverType(value: number): number;

    applyGravity(): void;
    applyDamping(timeStep: number): void;
    addConstraintRef(c: btTypedConstraint): void;
    applyImpulse(impulse: btVector3, rel_pos: btVector3): void;
    applyTorqueImpulse(torque: btVector3): void;
    applyCentralForce(force: btVector3): void;
    applyCentralImpulse(impulse: btVector3): void;
    applyForce(force: btVector3, rel_pos: btVector3): void;
    applyTorque(torque: btVector3): void;
    clearForces(): void;
    computeGyroscopicImpulseImplicit_Body(step: number): btVector3;
    computeGyroscopicImpulseImplicit_World(dt: number): btVector3;
    calculateSerializeBufferSize(): number;
    computeGyroscopicForceExplicit(maxGyroscopicForce: number): btVector3;
    computeAngularImpulseDenominator(axis: btVector3): number;
    computeImpulseDenominator(pos: btVector3, normal: btVector3): number;
    getCollisionShape(): btCollisionShape;
    getInvInertiaDiagLocal(): btVector3;
    getTotalForce(): btVector3;
    getLocalInertia(): btVector3;
    getInvInertiaTensorWorld(): btMatrix3x3;
    getInvMass(): number;
    getAngularDamping(): number;
    getCenterOfMassPosition(): btVector3;
    getOrientation(): btQuaternion;
    getLinearDamping(): number;
    getLinearVelocity(): btVector3;
    getAngularVelocity(): btVector3;
    getGravity(): btVector3;
    getVelocityInLocalPoint(rel_pos: btVector3): btVector3;
    getLinearSleepingThreshold(): number;
    getAabb(aabbMin: btVector3, aabbMax: btVector3): void;
    getLinearFactor(): btVector3;
    getTotalTorque(): btVector3;
    getBroadphaseProxy(): btBroadphaseProxy;
    getBroadphaseProxy(): btBroadphaseProxy;
    getMotionState(): btMotionState;
    getMotionState(): btMotionState;
    getAngularFactor(): btVector3;
    getAngularSleepingThreshold(): number;
    getCollisionShape(): btCollisionShape;
    getFlags(): number;
    getConstraintRef(index: number): btTypedConstraint;
    getNumConstraintRefs(): number;
    getCenterOfMassTransform(): btTransform;
    isInWorld(): boolean;
    integrateVelocities(step: number): void;
    predictIntegratedTransform(step: number, predictedTransform: btTransform): void;
    proceedToTransform(newTrans: btTransform): void;
    removeConstraintRef(c: btTypedConstraint): void;
    setAngularFactor(angFac: btVector3): void;
    setAngularFactor(angFac: number): void;
    setCenterOfMassTransform(xform: btTransform): void;
    setLinearFactor(linearFactor: btVector3): void;
    setGravity(acceleration: btVector3): void;
    setMassProps(mass: number, inertia: btVector3): void;
    saveKinematicState(step: number): void;
    serializeSingleObject(serializer: btSerializer): void;
    setFlags(flags: number): void;
    setDamping(lin_damping: number, ang_damping: number): void;
    setInvInertiaDiagLocal(diagInvInertia: btVector3): void;
    setNewBroadphaseProxy(broadphaseProxy: btBroadphaseProxy): void;
    setAngularVelocity(ang_vel: btVector3): void;
    setSleepingThresholds(linear: number, angular: number): void;
    setMotionState(motionState: btMotionState): void;
    serialize(dataBuffer: void, serializer: btSerializer): string;
    setLinearVelocity(lin_vel: btVector3): void;
    translate(v: btVector3): void;
    updateDeactivation(timeStep: number): void;
    updateInertiaTensor(): void;
    wantsSleeping(): boolean;
  }
}
